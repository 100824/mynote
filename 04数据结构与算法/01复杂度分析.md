#### 为什么需要复杂度分析
* 执行效率是算法一个非常重要的考量指标，是通过复杂度来衡量的。
* 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

#### 大 O 复杂度表示法
* 表示代码执行时间随数据规模增长的变化趋势，所以，也叫作时间复杂度。
* 大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。
##### 1. 只关注循环执行次数最多的一段代码

* 大O这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。**我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。

```
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

* 其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。这两行代码被执行了n次，所以总的时间复杂度就是O(n)。

##### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
* 总的时间复杂度就等于量级最大的那段代码的时间复杂度。

##### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 常见时间复杂度
1. O(1) 常量级，即不会随着n的大小改变而改变  
只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)
2. O(logn)、O(nlogn)  
log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。  
所以，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn).  
O(nlogn)就是前一种再加上乘法法则，再嵌套一层执行n遍。
3. O(m+n)、O(m*n)
代码的复杂度由两个数据的规模来决定  

#### 空间复杂度
算法的存储空间与数据规模之间的增长关系。  
常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

#### 最好、最坏时间复杂度
* 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。
* 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。

#### 平均情况时间复杂度
* 通过加权平均值等方式，得出平均时间复杂度的公式，再通过大 O 标记法，省略掉系数、低阶、常量，把公式简化之后，就得到平均时间复杂度。 

#### 均摊时间复杂度
* 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，**一般均摊时间复杂度就等于最好情况时间复杂度**。

#### 课后思考

我们今天学的几个复杂度分析方法，你都掌握了吗？你可以用今天学习的知识，来分析一下下面这个add()函数的时间复杂度。

```
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```
* 答：  
1. 最好时间复杂度O(1),只执行了写入操作
2. 最坏时间复杂度O(n),i>=len,复制数组循环了n次
3. 平均时间复杂度O(1)， (1+1+...+1+n)/(n+1) = 2n/(n+1)，化简后为常数级












